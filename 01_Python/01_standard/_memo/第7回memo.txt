【アプリケーションプロトコル】RFCで標準化
クライアントから送信されるリクエスト + サーバーから返信されるレスポンスの形式 で別れる。

・「テキストベースプロトコル」
自然言語に近い。ASCII文字列を用いる。※HTTPはこちら
・「バイナリーベースプロトコル」
コンピュータ処理に最適化されたバイナリーメッセージを用いる。


【HTTP】
クライアントとサーバーの間で交わされるプロトコル
1回のリクエストで取得できるリソースは1つ

HTTP/1.1：
持続的接続（Persistent Connection）に対応	※HTTPの持続的接続機能を「HTTP Keep Alive」
※HTTP/1.1より前のHTTP/1.0では、リクエスト／レスポンスをやり取りする度に、TCPコネクションの接続／切断が行われていました。

「パイプライン処理（Pipelining）」に対応
クライアン卜がレスポンスを待たずに続けてリクエストを送信できる


【HTTPの良さ】
・ステートレス性
前後に行われるHTTP接続の状態（ステート）を管理・維持しない。
状態を管理しないプロトコルを「ステートレスプロトコル」と呼ぶ
1回1回のリクエスト／レスポンスが短いため、サーバーを分散しやすく、
台数を増やしてパフォーマンスを向上する「スケールアウト」と言われる手法で、システムを簡単に増強できます。



【HTTPメッセージ】
ブラウザから送信されるリクエストもWebサーバーから返送されるレスポンスもこちら


【リクエストメッセージ】
リクエストメッセージは空行を境に、前半がヘッダー、後半がボディで構成されています。
ヘッダーの1行目：「リクエストライン」
メゾッド + 空白 + リクエストURL + 空白 + HTTPバージョン（今だとHTTP/1.1）
（例：GET http://www.cyber-u.ac.jp/faculty/teacher/tsurunaga_shinichi.html HTTP/1.1）


「HTTP/1.1で使えるメゾッド」
◯------------------------------------------------------------◯
メソッド	|内容
----------------------------------------------
GET	|クライアントが指定したURLのリソースを取得
POST	|GETとは反対にクライアントからサーバーにデータを送信
PUT	|指定したURLにリソースを保存、更新
HEAD	|ヘッダー情報のみ取得
OPTIONS	|利用可能なメソッドなどのサーバー情報を取得
DELETE	|指定したリソースの削除
TRACE	|リクエストのループバックでサーバーまでのネットワーク経路をチェック
CONNECT	|プロクシへのトンネル要求
◯------------------------------------------------------------◯
※通常のWebブラウジングでは、GET／HEAD／POST以外のメソッドは利用されない。

ただし、HTTP/1.1ではスキーム（http:）やオーソリティ（//gihyo.jp）を省略するのが一般的
（例：GET /faculty/teacher/tsurunaga_shinichi.html HTTP/1.1
Host: www.cyber-u.ac.jp）
オーソリティで示されるホスト名やポート番号は、次に紹介する「ヘッダー」内の「Host:」ヘッダーで指定。

注：ただしProxyサーバーに対してリクエストを送信する場合はホスト名を含んだ絶対URLを用います。


ボディは省略可能
(PUTメゾッドのときはボディに送信内容をふくめる。)






【レスポンスメッセージ】

[HTTPステータスコード]
◯------------------------------------------------------------◯
	|概要				|説明
------------------------------------------------------------
100番台	|情報（Informational）		|処理が継続されていることを通知。ほとんと使われていない。
200番台	|成功（Success）			|リクエストの処理に成功したことを通知。
300番台	|リダイレクト（Redirection）	|リクエストを完遂するには、さらに新たな動作が必要であることを通知。
400番台	|クライアントエラー（Client Error）	|リクエストの内容に問題があるためリクエスト処理に失敗したことを通知。
500番台	|サーバーエラー（Server Error）	|リクエスト処理中にサーバーにエラーが発生したことを通知。
◯------------------------------------------------------------◯




大きなサイズのデータを返答するために…

【コンテンツエンコーディング（圧縮転送）】
コンテンツを変換（圧縮する）→　高速化出来る。
クライアントからサーバーへのリクエスト：「Accept-Encoding:」ヘッダー
	（クライアントが対応している圧縮方式をサーバーに通知）
レスポンス：「Content-Encoding:」ヘッダー
	（実際に使用した圧縮方式）


【転送エンコーディング（分割転送）】
大きなサイズのデータを分割転送する。
レスポンス：「Transfer-Encoding: chunked」ヘッダー
	（分割したデータをそのサイズとともにクライアントに転送）
	（付記サイズが0になる→クライアント側でリソースの転送完了を検知できる。）
サーバー側もデータの用意できたものから順次送れるため、バッファに貯めておく必要がない。負荷が軽くなる。
























